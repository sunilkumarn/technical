---
author: sunilkumarn
comments: true
date: 2010-09-23 20:49:32+00:00
layout: post
slug: an-overview-of-tinypy
title: An Overview of TinyPy
wordpress_id: 222
categories:
- Tinypy
---

TinyPython is a minimalist implementation of Python in 64K code. It is a parser and byte-code compiler written in TinyPython itself. It is also fully bootstrapped in the sense that initially, TinyPython converts a Python script (.py) into a special TinyPy byte-code format (.tpc), and this generated code is then passed into a  subset of the TinyPython source code called the Virtual Machine, where the actual execution takes place. 

One can even extend the idea that if the VM is compiled into a low-level format adaptable to a particular micro controller, then the VM will reside inside that chip, and any .tpc files can be downloaded into the chip as its input. 

As outlined above, TinyPy comprises of two phases: the byte-code generation, and the execution of the byte-code in the TinyPy Virtual Machine. Out of these, the first phase will not be mentioned here.

_**Building Up**_
The TinyPython source code used was downloaded from [here](http://code.google.com/p/tinypy/downloads/list). Initially, the file listing will look like the following figure.

[![](http://sunilkumarn.files.wordpress.com/2010/09/image-01.png?w=300)](http://sunilkumarn.files.wordpress.com/2010/09/image-01.png)

You can find that the 'build' folder will be empty. The 'doc', 'examples' and 'modules' folder may or may not contain any documents, Python scripts and batteries (or modules) respectively, depending on the downloaded package. The LICENSE.txt and README.txt are self-explanatory names. The CHANGES.txt contain a record of all the changes that the author of TinyPy thought of making in the source code at some point. The ROADMAP.txt gives a brief description of the features of TinyPy, and an idea about the future developments to be implemented. The 'setup.py' contains the initial code to build the TinyPy from scratch. At the terminal, type as follows:
**python setup.py linux
**
It is implied that you need a Python interpreter available in your system. The 'linux' option is to specify that the code will be compiled so as to make it work in a Linux environment. After running this command, a new executable 'tinypy' will appear in the 'build' folder as shown.

[![](http://sunilkumarn.files.wordpress.com/2010/09/image-3.png?w=300)](http://sunilkumarn.files.wordpress.com/2010/09/image-3.png)

To fully bootstrap and test TinyPy, give the command as,
**python setup.py linux boot**

Now, in the 'tinypy' folder shown in the above figure, two new executables, 'tinypy' and 'vm' will appear, which are the TinyPy parser, and Virtual Machine respectively. It can be noticed that all the .pyc files for the corresponding .py files have been generated by the Python interpreter. In addition to that, some test scrips - named as Temp - will be invoked too. The most interesting thing will be the presence of new **.tpc** files for some of the initial **.py** files. The general usage and some options available are listed below.

python setup.py command [option] [module]
• 64 k - build a a64k version of TinyPy source code 
• blob - build a single tinypy.c and tinypy.h

The tinypy folder will now have the following contents: Out of these, the 'py2bc.py' script is used to convert a user-generated Python script into its corresponding .tpc file. The format will be:
 **py2bc.py sample.py sample.tpc**

Here, tinypy_path is the path (relative to current position) of either the tinypy executable in the 'build' folder, or the one in the 'tinypy' folder. 'sample.py' is the name of the user-script. 'sample.tpc' is the name given for the byte-code converted file. Or you can simply give it as:
**python py2bc.py sample.py sample.tpc**

Finally, the generated byte-code (.tpc) is to be passed into the VM for compilation and execution. Assuming the current directory as 'tinypy' folder, it is done as:
**vm sample.tpc
**
Or logically,
**gcc vmmain.c -lm ./a.out sample.tpc**

The 'vmmain.c' will be present in the 'tinypy' folder. It is the main function of the VM which runs and automatically links to all the other files necessary for the VM. It is necessary to link the math module too, hence the option '-lm'. And now the output is obtained and displayed. For a better picture, the files actually needed for VM are:

[![](http://sunilkumarn.files.wordpress.com/2010/09/image-4.png?w=300)](http://sunilkumarn.files.wordpress.com/2010/09/image-4.png)

Writing and compiling the code only accounts to half of the process. The other half is debugging and understanding the flow of control within the source code. To do that, make use of the GNU debugging tool, 'gdb'.
**gcc -g vmmain.c -lm gdb ./a.out**

Inside the 'gdb', you can set breakpoint for any function. Then run the process for the byte-code you need. Here, 'sample.tpc' is used as example.

**(gdb) run sample.tpc OR r sample.tpc**

Another essential tool will be 'ctags'. After its installed, go to the 'tinypy' folder and build the tag stack as follows:

**ctags *.c *.h**

You can see that a new file named 'tags' is now available. Now when you are inside a .c or a.h file, you can use 'ctrl + ]' and 'ctrl + T' to jump back and forth between cross references spanning different files.

