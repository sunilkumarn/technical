<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Scribblings]]></title>
  <link href="http://sunilkumarn.github.io/technical/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://sunilkumarn.github.io/technical/"/>
  <updated>2013-09-15T16:39:49+05:30</updated>
  <id>http://sunilkumarn.github.io/technical/</id>
  <author>
    <name><![CDATA[Sunil Kumar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Memcheck : A Memory Error Detection Tool]]></title>
    <link href="http://sunilkumarn.github.io/technical/2010/10/21/memcheck-a-memory-error-detection-tool"/>
    <updated>2010-10-21T09:13:49+05:30</updated>
    <id>http://sunilkumarn.github.io/technical/2010/10/21/memcheck-a-memory-error-detection-tool</id>
    <content type="html"><![CDATA[<p>Linux distros provide a  tool suite called <strong>&lsquo;Valgrind&rsquo;</strong> that consists of a number of tools that help you make your programs faster and more correct . The most popular tool out of this is called is <strong>memcheck</strong> that is used to detect memory related errors in C and C++ programs that can lead to serious issues like  segfaults and even more grevious issues like unpredictable behaviours .</p>

<p>Lets take a look into how we use the tool &lsquo;memcheck&rsquo; so that we detect , try and avoid the memory related issues in our program.</p>

<p>First of all we need to create a memory leak so that we have something to detect .</p>

<p>We write a program that consists of a memory leak . Here is one such in a file &lsquo; pgm.c&rsquo;</p>

<p><code>1 #include &lt;stdlib.h&gt;
2 #include &lt;string.h&gt;
3 void f(char *s)
4 {
5 char *x = malloc(strlen(s));
6 x[7] = 0;
7 }</code></p>

<p><code>8 int  main()
9 {
10 char *s="Hello";
11 f(s);
12 }</code></p>

<p>As you could see , there are two major memory related bugs in this code:</p>

<p>1) Trying to write in the location x[7] which is out of the allocated memory space .This will lead to what is called a <strong>&lsquo;heap block overrun</strong>&rsquo; .</p>

<p>2) The memory that is allocated to x remains unused . This memory becomes garbage on returning from the function . In short , you have seen a <strong>&lsquo;memory leak</strong> &rsquo;.</p>

<p>Now lets try and detect the two problems using memcheck :</p>

<p>You need to have valgrind installed in your system .
<strong>$ : apt-get install valgrind</strong>
if you don&rsquo;t have it already .</p>

<p>Do</p>

<p><strong>$: cc -g pgm.c</strong></p>

<p>We  compile the program using the -g option so that the line number informations are displayed when using memcheck .</p>

<p>Do</p>

<p><strong>$: valgrind  &mdash;leak-check = yes a.out</strong></p>

<p>the option  &lsquo; &mdash;leak-check &rsquo; being set equal to yes displays the informations on memory leak issues .</p>

<p>Now lets look out what are the informations that are being displayed when the memcheck tool is used .</p>

<p>First lets have a look into the &lsquo;heap block overrun&rsquo; problem :</p>

<p><code>==3350== Invalid write of size 1
==3350==    at 0x80483F6: f (pgm.c:6)
==3350==    by 0x804841D: main (pgm.c:11)
==3350==  Address 0x419102f is 2 bytes after a block of size 5 alloc'd
==3350==    at 0x4023D6E: malloc (vg_replace_malloc.c:207)
==3350==    by 0x80483EC: f (pgm.c:5)
==3350==    by 0x804841D: main (pgm.c:11)</code></p>

<p>The above few lines is the code that was generated by memcheck  .</p>

<p>&lsquo;3350&rsquo; is the process id .</p>

<p>The actual error is seen right at the first line .</p>

<p>&lsquo;Invalid write  of size 1&rsquo; .</p>

<p>You get a stack trace right after this line , that</p>

<p>the invalid write has occured at the 6th line as a result of the 12th line . You could see what line numbers &lsquo;6&rsquo; and &lsquo;11&rsquo; do by having a look into our code , its the point of occurence of the error and the function call respectively.</p>

<p>A line showing the the fact that the location you are trying to access ( x[7] ) is 2 bytes after the allocated area can also be seen added with lines that contain information about the main and the function   .These lines provide great help to the programmer especially when the case becomes a lot more complicated .</p>

<p>Now the informations that are displayed about the &lsquo;memory leak problem&rsquo; can also be looked into .</p>

<p><code>==3350== LEAK SUMMARY:
==3350==    definitely lost: 5 bytes in 1 blocks.
==3350==    possibly lost: 0 bytes in 0 blocks.
==3350==    still reachable: 0 bytes in 0 blocks.
==3350==    suppressed: 0 bytes in 0 blocks.
</code>
You could view the lines that provide information about the memory leak problem .
The first line of the &lsquo;LEAK SUMMARY &rsquo; is the most significant to us . It shows the amount of memory definitely lost ( 5 Bytes ). Changes need to be made in the program so that the memory leak is prevented .</p>

<p>Memcheck produces these result which helps the programmer so as to view and correct the memory related issues rather convincingly . It needs to be noted that Memcheck is a <strong>&lsquo;dynamic instrumentation tool </strong>&rsquo; and not a static tool like &lsquo;lint &rsquo; . Hence to detect the memory leaks in a program , the control actually needs to get transferred to that segment of the program where the issues occur . In short you need to invoke the function &lsquo;f&rsquo; from your &lsquo;main&rsquo; so that Memcheck could detect those memory related issues that exists within the function &lsquo;f&rsquo; .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNU make]]></title>
    <link href="http://sunilkumarn.github.io/technical/2010/10/04/280"/>
    <updated>2010-10-04T00:05:22+05:30</updated>
    <id>http://sunilkumarn.github.io/technical/2010/10/04/280</id>
    <content type="html"><![CDATA[<p>The make utility determines which pieces of the program needs to be recompiled and issues instructions to recompile them.GNU make is the most popular make available. Lets get into the working of make with a simple example but please do read <a href="http://sunilkumarn.wordpress.com/2010/10/03/swigsimplified-wrapper-and-interface-generator/">THIS</a> before moving into further details.</p>

<p>By reading that, you would have understood that our ultimate aim is to produce a file &lsquo;_avl.so&rsquo; so that the C module &lsquo;avl.c&rsquo; could be extended into Python.
Lets check what exactly do we need to do here.</p>

<p>We begin with 2 files namely &lsquo;avl.c&rsquo; and &lsquo;avl.i&rsquo;. We need to create a wrapper file at first . This is done by:</p>

<p><strong>$: swig -python avl.i</strong></p>

<p>Next what we need to do is that we need to create 2 object files for the respective C files- i.e we need to produce &lsquo;avl.o&rsquo; and &lsquo;avl_wrap.o&rsquo; from &lsquo;avl.c&rsquo; and &lsquo;avl_wrap.c&rsquo; respectively.
We do this by:</p>

<p><strong>$: gcc -c avl.c avl_wrap.c -I /usr/include/python2.5/</strong></p>

<p>The last and final step is to create &lsquo;_avl.so&rsquo; from the 2 object files.</p>

<p><strong>$: ld -shared avl.o avl_wrap.o -o _avl.so </strong></p>

<p>The dependencies and actions are quite clear now.
<a href="http://sunilkumarn.files.wordpress.com/2010/10/make.png"><img src="http://sunilkumarn.files.wordpress.com/2010/10/make.png" alt="" /></a></p>

<p>Typing in these commands time and again would be a tedious and ineffective job for anyone. We could automate the whole process by writing a file called Makefile and use the &lsquo;make&rsquo; utility.</p>

<p>The Makefile for performing the above steps would be as follows:</p>

<p><a href="http://sunilkumarn.files.wordpress.com/2010/10/makefile3.png"><img src="http://sunilkumarn.files.wordpress.com/2010/10/makefile3.png?w=300" alt="" /></a></p>

<p>A Makefile has the following format.</p>

<p><a href="http://sunilkumarn.files.wordpress.com/2010/10/new3.png"><img src="http://sunilkumarn.files.wordpress.com/2010/10/new3.png?w=300" alt="" /></a></p>

<p>Its important to note that the &lsquo;ACTIONS&rsquo; line begins with a TAB as it is a part of the syntax of a Makefile. Anything other than TAB would be harmful.</p>

<p>Lets check out how things work out.</p>

<p><strong>$: make</strong></p>

<p>This would cause GNU make to start executing the commands in Makefile.GNU make starts from the very beginning of the Makefile. The first set of &lsquo;TARGET-DEPENDENCIES-ACTIONS are checked in.</p>

<p>The TARGET is &lsquo;_avl.so&rsquo; : The DEPENDENCIES are &lsquo;avl.o and avl_wrap.o&rsquo; and the ACTION that needs to be performed is</p>

<p><strong>ld -shared avl.o avl_wrap.o -o _avl.so</strong></p>

<p>But at present &lsquo;avl.o&rsquo; and &lsquo;avl_wrap.o&rsquo; are not available. To Generate them the next set of the Makefile is to be checked. The same problem exists there as well . Hence the 3rd set in the Makefile is reached where the DEPENDENCY is &lsquo;avl.i&rsquo; which exists at present. Hence the action</p>

<p><strong>swig -python avl.i
</strong>
is executed , the target &lsquo;avl_wrap.c&rsquo; is generated .
Now the second set in the Makefile can be compiled followed by the compilation of the first set. The procedure that takes place here is recursive .All the three actions are executed , the TARGETS are generated from the ACTIONS and DEPENDENCIES and finally we obtain &lsquo;_avl.so&rsquo;.</p>

<p>You could see another line in the Makefile that has not been mentioned upto now.
<strong>make remove</strong>
make remove is the TARGET and the ACTION that needs to be performed is
<strong>rm avl.o avl_wrap.o avl.py _avl.so avl_wrap.c avl.pyc</strong></p>

<p><strong>$: make remove</strong></p>

<p>will remove all the unnecessary files in the directory when you are planning to start from the beginning.</p>

<p>If you would like to have a test on the intelligence of &lsquo;make&rsquo; , you would be pretty surprised.</p>

<p>Lets deal that case with an example as well.</p>

<p>DO:</p>

<p><strong><strong>$:  swig -python avl.i</strong></strong></p>

<p>We have executed the first command manually.
Now do:</p>

<p><strong>$: make</strong></p>

<p>and you will find that make executes only the other two commands that is included in the Makefile.
This again shows the recursive nature of the make process. The Makefile is read from the top. On reaching the second set , GNU make realizes that both the dependencies &lsquo;avl.c&rsquo; and &lsquo;avl_wrap.c&rsquo; are available and executes the ACTION to produce the TARGET &lsquo;avl.o&rsquo; and &lsquo;avl_wrap.o&rsquo;.</p>

<p>Now once again do
<strong>$: make</strong></p>

<p>You would get a message as follows:
<strong>make: `_avl.so' is up to date.</strong></p>

<p>This again brings to the fort-light the power of make. The final target &lsquo;_avl.so&rsquo; has been found to be &lsquo;up to date&rsquo; and hence there is no question of having to execute the commands in the Makefile . GNU make, <strong>Richard Stallman and Rolland Mcgrath&rsquo;s creation</strong>, has recognized this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SWIG(Simplified Wrapper and Interface Generator).]]></title>
    <link href="http://sunilkumarn.github.io/technical/2010/10/03/swigsimplified-wrapper-and-interface-generator"/>
    <updated>2010-10-03T21:02:07+05:30</updated>
    <id>http://sunilkumarn.github.io/technical/2010/10/03/swigsimplified-wrapper-and-interface-generator</id>
    <content type="html"><![CDATA[<pre><code>Scripting languages like python presents a lot of ease to the programmer while coding , but the fact remains that there are certain tasks that would screw you up when attempted in Python. So the coding is done in a more flexible language like C and the modules are imported in Python. **SWIG** is a tool that is used for extending your C programs into python and make the functions callable from Python.
</code></pre>

<p>Here we discuss how to import a C module into Python using SWIG.
Installing SWIG in your system ,if you haven&rsquo;t already, is the first task.</p>

<p><strong>$:apt-get install swig</strong></p>

<p>would do that for you.</p>

<p>Now its better you create a directory for the entire purpose and setup yourself within it.
Consider you have a C file ,<strong>avl.c</strong> , as our example<em> (Avl is a height balanced Tree ,avl.c is an implementation of such a tree.</em>) You could download the source code for avl.c <a href="http://github.com/sunilkumarn/Avl_Tree">here</a>.</p>

<p>Our first step is to create an interface file &lsquo;<strong>avl.i</strong>&rsquo; for setting up the interface. &lsquo;avl.i &rsquo; consists of the declarations of the various functions and global variables that are used in the file &lsquo;avl.c&rsquo; and are prefixed with &lsquo;extern&rsquo;.</p>

<p>`%module avl</p>

<p>%{</p>

<pre><code>extern struct node *root;

    extern struct node *p;
</code></pre>

<p>%}</p>

<p>extern void insert(struct node* move,int item);</p>

<p>&hellip;
&hellip;
&hellip;
&hellip;
`
The &lsquo;avl.i &rsquo; file would like as above:
Now we have two files in our directory ,</p>

<p>avl.c   &amp;   avl.i</p>

<p>This is all that we have to code for the task of extending a C module in Python. Now its all about SWIG.</p>

<p><a href="http://sunilkumarn.files.wordpress.com/2010/10/swig.png"><img src="http://sunilkumarn.files.wordpress.com/2010/10/swig.png" alt="" /></a>
Lets move further: Do the following.</p>

<p><strong>$:swig -python avl.i
</strong>
now have have a look into your directory and you will find two more files there .</p>

<p>avl.py  &amp;   avl_wrap.c    <br/>
<strong>avl_wrap.c</strong> is the wrapper file that has been created for the purpose of extension . Wrapper functions act as a glue layer between languages.</p>

<p><strong>$: gcc -c avl.c avl_wrap.c -I /usr/include/python2.5/</strong></p>

<p>You could now see 2 more files present in your directory.
avl.o   &amp;     avl_wrap.o</p>

<p>These two are the object files that have been created for avl.c and avl_wrap.c respectively.</p>

<p><strong>$: ld -shared avl.o avl_wrap.o -o _avl.so</strong></p>

<p>This is the last thing you need to do before you could use start using your C module in Python.
Check your directory and you could see a new file ,<strong> &lsquo;_avl.so&rsquo;</strong>. This is the shared object file that has been created .
If you create a make file for these , then obviously you wont have to go doing these tasks repeatedly.
Now ,the python module corresponding to the C module avl.c has been created which means that now you could start using it.</p>

<p><strong>$: python</strong></p>

<blockquote><blockquote><blockquote><p>import avl
avl.my_insert(10)
avl.my_insert(20)
avl.traverse(1)</p></blockquote></blockquote></blockquote>

<p>The source code can be downloaded <a href="http://github.com/sunilkumarn/Extending_into_python">here.
</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging with the GDB]]></title>
    <link href="http://sunilkumarn.github.io/technical/2010/08/08/debugging-with-the-gdb"/>
    <updated>2010-08-08T22:35:48+05:30</updated>
    <id>http://sunilkumarn.github.io/technical/2010/08/08/debugging-with-the-gdb</id>
    <content type="html"><![CDATA[<p>GNU debugger(GDB) allows you to view the step by step execution of the program code. This proves of great help in executing complex programs(specially the ones involving recursion) to see the exact flow of control. How to debug using the gdb and a few options used are worth notable:
To debug a program with gdb , steps followed are
&lsquo;cc -g file.c&rsquo;
gdb a.out. &hellip;.&lsquo;a.out is your executable&hellip;&rsquo;
You will see messages about the gdb version displayed on the terminal&hellip;.
Now set the break point by
&lsquo;break main&rsquo;
Use the &lsquo;run&rsquo; command to start running the program.
The 3 commonly used options are &rsquo;s' ,&lsquo;n&rsquo; ,&lsquo;q&rsquo; with the gdb are…
&rsquo;s' moves to the next line of code-it enters functions as well.
&lsquo;n&rsquo; moves to the next line of code as well but does not enter functions.
&lsquo;q&rsquo; is used to quit from the process.</p>

<p>A debugging process would be like this&hellip;</p>

<p>sunil:~/new# cc -g quicksort.c
sunil:~/new# gdb a.out
<strong>GNU gdb 6.8-debian
Copyright &copy; 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later<br/>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &ldquo;show copying&rdquo;
and &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;i486-linux-gnu&rdquo;&hellip; </strong>
(gdb) break main
<strong>Breakpoint 1 at 0x80483e5: file quicksort.c, line 7</strong>.
(gdb) run
<strong>Starting program: /root/new/a.out
Breakpoint 1, main () at quicksort.c:7
7       int left=0,right=4,i; </strong>
(gdb) s
8       <strong>int array[]={4,8,1,9,3};
&hellip;/<em>
&hellip;continue the process&hellip;
&hellip;/</em></strong>
(gdb) q
Quits from the debugger</p>
]]></content>
  </entry>
  
</feed>
